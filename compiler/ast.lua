--[[ Module defines all of the AST nodes used to represent the Liszt 
     language.
]]--
local A = {}
package.loaded["compiler.ast"] = A

---------------------------
--[[ Declare AST types ]]--
---------------------------
local AST             = { kind = 'ast', is_liszt_ast = true }
AST.__index           = AST

function A.is_ast(obj)
  local mt = getmetatable(obj)
  if mt and mt.is_liszt_ast then
    return true
  else
    return false
  end
end

local LisztKernel     = { kind = 'kernel' }
local UserFunction    = { kind = 'user_function' }
local Block           = { kind = 'block'  } -- Statement*
  -- store condition and block to be executed for if/elseif clauses
local CondBlock       = { kind = 'condblock' } 

-- Expressions:
local Expression      = { kind = 'expr'   } -- abstract
local BinaryOp        = { kind = 'binop'  }
local Reduce          = { kind = 'reduce' }
local UnaryOp         = { kind = 'unop'   }

local TableLookup     = { kind = 'lookup' }
local VectorIndex     = { kind = 'index'  }
local Call            = { kind = 'call'   }

local Name            = { kind = 'name'   }
local Number          = { kind = 'number' }
local String          = { kind = 'string' }
local Bool            = { kind = 'bool'   }
  -- e.g. {0, 4, 3} {true, true, false}
local VectorLiteral   = { kind = 'vecliteral' } 

-- non-syntactic expressions (i.e. these will not be generated by the parser)
local FieldAccess     = { kind = 'fieldaccess' } -- type determined by field type
local FieldWrite      = { kind = 'fieldwrite'  }
local Global          = { kind = 'global'      } -- type determined by global type
local GlobalReduce    = { kind = 'globalreduce' }
local Cast            = { kind = 'cast'        } -- called "function" is a type, cast to that type

local QuoteExpr       = { kind = 'quoteexpr'   } -- type already checked, just return checked AST
local LuaObject       = { kind = 'luaobject' } --reference to a special Lua object, type is already provided
local Where           = { kind = 'where'     }

-- Statements:
local Statement       = { kind = 'statement'  }  -- abstract
  -- if expr then block (elseif cond then block)* (else block)? end
local IfStatement     = { kind = 'ifstmt'     }
local WhileStatement  = { kind = 'whilestmt'  }  -- while expr do block end
local DoStatement     = { kind = 'dostmt'     }  -- do block end
local RepeatStatement = { kind = 'repeatstmt' }  -- repeat block until cond
local ExprStatement   = { kind = 'exprstmt'   }  -- e;
local Assignment      = { kind = 'assnstmt'   }  -- "lvalue   = expr" 
local DeclStatement   = { kind = 'declstmt'   }  -- "var name"
local NumericFor      = { kind = 'numericfor' }
local GenericFor      = { kind = 'genericfor' }
local Break           = { kind = 'break'      }


----------------------------
--[[ Set up inheritance ]]--
----------------------------
local function inherit (child, parent, child_asts, child_ast_lists)
  child.__index = child -- readies child as metatable for inheritance
  -- these are the names of fields that contain topology of the AST
  child.__child_asts      = child_asts or {}
  child.__child_ast_lists = child_ast_lists or {}
  local blacklist = {}
  for _,n in ipairs(child.__child_asts) do blacklist[n] = true end
  for _,n in ipairs(child.__child_ast_lists) do blacklist[n] = true end
  child.__blacklist = blacklist
  setmetatable(child, parent)
end

inherit(LisztKernel, AST, {'set', 'body'})
inherit(UserFunction, AST, {'params', 'body', 'exp'})
inherit(Expression,  AST)
inherit(Statement,   AST)
inherit(Block,       AST, nil, {'statements'})
inherit(CondBlock,   AST, {'cond','body'})

inherit(BinaryOp,      Expression,  {'lhs', 'rhs'})
inherit(UnaryOp,       Expression,  {'exp'})
inherit(Number,        Expression)
inherit(String,        Expression)
inherit(Bool,          Expression)
inherit(VectorLiteral, Expression,  nil, {'elems'})

inherit(Call,          Expression,  {'func'}, {'params'})
inherit(TableLookup,   Expression,  {'table', 'member'})
inherit(VectorIndex,   Expression,  {'vector', 'index'})
inherit(Name,          Expression)
inherit(Reduce,        Expression,  {'exp'})

inherit(Global,        Expression)
inherit(FieldAccess,   Expression)
inherit(Cast,          Expression,  {'value'})
inherit(QuoteExpr,     Expression,  {'block', 'exp'})
inherit(LuaObject,     Expression)
inherit(Where,         Expression)

inherit(IfStatement,     Statement, {'else_block'}, {'if_blocks'})
inherit(WhileStatement,  Statement, {'cond', 'body'})
inherit(DoStatement,     Statement, {'body'})
inherit(RepeatStatement, Statement, {'cond', 'body'})
inherit(ExprStatement,   Statement, {'exp'})
inherit(Assignment,      Statement, {'lvalue','exp'})
inherit(GlobalReduce,    Statement, {'global', 'exp'})
inherit(FieldWrite,      Statement, {'fieldaccess','exp'})
inherit(DeclStatement,   Statement, {'typeexpression','initializer'})
inherit(NumericFor,      Statement, {'lower','upper','step','body'})
inherit(GenericFor,      Statement, {'set','body'})
inherit(Break,           Statement)


-----------------------------
--[[ Lvalue flags        ]]--
-----------------------------
FieldAccess.is_lvalue = true
Global.is_lvalue      = true
Name.is_lvalue        = true

-----------------------------
--[[ General AST Methods ]]--
-----------------------------
function AST:New (P)
  local newnode = 
  { 
    kind       = self.kind, -- Is this even necessary?
    linenumber = P:cur().linenumber,
    filename   = P.source,
    offset     = P:cur().offset,
  }
  return setmetatable(newnode, self)
end

function AST:copy_location (node)
  self.linenumber = node.linenumber
  self.filename   = node.filename
  self.offset     = node.offset
end

function AST:DeriveFrom (ast)
  local newnode = setmetatable({kind=self.kind}, self)
  newnode:copy_location(ast)
  newnode.name      = ast.name
  return newnode
end

function AST:clone ()
  local copy = setmetatable({}, getmetatable(self))
  for k,v in pairs(self) do
    if not self.__blacklist[k] then copy[k] = v end
  end
  return copy
end

-- STRUCTURAL RECURSION
-- useful for implementing sparse passes on the AST quickly
function AST:passthrough(call, ctxt_arg)
  local copy = self:clone()
  
  -- perform the requested call recursively on the children
  for _,n in ipairs(self.__child_asts) do
    if self[n] then
      if not A.is_ast(self[n]) then 
        copy[n] = self[n]
      else
        copy[n] = self[n][call](self[n], ctxt_arg)
      end
    end
  end
  for _,n in ipairs(self.__child_ast_lists) do
    if self[n] then
      copy[n] = {}
      for i, node in ipairs(self[n]) do
        if not A.is_ast(node) then
          copy[n][i] = node
        else
          copy[n][i] = node[call](node, ctxt_arg)
        end
      end
    end
  end

  return copy
end
function AST:callthrough(call, ctxt_arg)
  -- perform the requested call recursively on the children
  for _,n in ipairs(self.__child_asts) do
    local node = self[n]
    if A.is_ast(node) then
      node[call](node, ctxt_arg)
    end
  end
  for _,n in ipairs(self.__child_ast_lists) do
    if self[n] then
      for i, node in ipairs(self[n]) do
        if A.is_ast(node) then
          node[call](node, ctxt_arg)
        end
      end
    end
  end
end

function AST:is (obj)
  return obj == getmetatable(self)
end

---------------------------
--[[ AST tree printing ]]--
---------------------------
local indent_delta = '   '

function AST:pretty_print(indent)
  error('PRETTY PRINT not implemented for AST node ' .. self.kind)
end

function LisztKernel:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (name, set, body)")
  indent = indent .. indent_delta
  print(indent .. self.name)
  if self.set then
    self.set:pretty_print(indent)
  else
    print(indent .. 'nil')
  end
  self.body:pretty_print(indent)
end

function UserFunction:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (params, body, exp)")
  indent = indent .. indent_delta
  for i = 1, #self.params do
    print(indent .. self.params[i])
  end
  self.body:pretty_print(indent)
  if not self.exp then
    print(indent..indent_delta..'nil')
  else
    self.exp:pretty_print(indent)
  end
end

function Block:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind)
  for i = 1, #self.statements do
    self.statements[i]:pretty_print(indent .. indent_delta)
  end
end

function CondBlock:pretty_print (indent)
  print(indent .. self.kind .. ": (cond, block)")
  self.cond:pretty_print(indent .. indent_delta)
  self.body:pretty_print(indent .. indent_delta)
end

function BinaryOp:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. self.op)
  self.lhs:pretty_print(indent .. indent_delta)
  self.rhs:pretty_print(indent .. indent_delta)
end

function UnaryOp:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. self.op)
  self.exp:pretty_print(indent .. indent_delta)
end

function Reduce:pretty_print(indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. self.op)
  self.exp:pretty_print(indent .. indent_delta)
end

function Global:pretty_print(indent)
  indent = indent or ''
  local name = self.name or ""
  print(indent .. self.kind .. ": " .. name)
end

function Cast:pretty_print(indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. tostring(self.node_type))
  self.value:pretty_print(indent .. indent_delta)
end

function QuoteExpr:pretty_print(indent)
    indent = indent or ''
    local str = indent .. self.kind .. ": ("
    if self.block then str = str .. "block, " end
    if self.exp then str = str .. "exp" end
    print(str .. ")")
    indent = indent .. indent_delta
    if self.block then
      self.block:pretty_print(indent)
    end
    if self.exp then
      self.exp:pretty_print(indent)
    end
end

function FieldAccess:pretty_print(indent)
  indent = indent or ''
  print(indent .. self.kind .. ': ' .. tostring(self.field))
end

function VectorLiteral:pretty_print(indent)
  indent = indent or ''
  print(indent .. self.kind)
  for i = 1, #self.elems do
    self.elems[i]:pretty_print(indent .. indent_delta)
  end
end

function Call:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (func, params)")
  if not A.is_ast(self.func) then
    print(indent .. indent_delta .. tostring(self.func))
  else
    self.func:pretty_print(indent .. indent_delta)
  end
  for i = 1, #self.params do
    self.params[i]:pretty_print(indent .. indent_delta)
  end
end

function LuaObject:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. tostring(self.value))
end

function TableLookup:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (table, member)")
  self.table:pretty_print(indent .. indent_delta)
  if A.is_ast(self.member) then
    self.member:pretty_print(indent .. indent_delta)
  else
    print(indent .. indent_delta .. tostring(self.member))
  end
end

function VectorIndex:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (vector, index)")
  self.vector:pretty_print(indent .. indent_delta)
  self.index:pretty_print(indent .. indent_delta)
end

function Name:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. self.name)
end

function Number:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. self.value)
end

function Bool:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ':' .. self.value)
end

function String:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": \"" .. self.value .. "\"")
end

function IfStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind)
  for i = 1, #self.if_blocks do
    self.if_blocks[i]:pretty_print(indent .. indent_delta)
  end
  if self.else_block then
    self.else_block:pretty_print(indent .. indent_delta)
  end
end

function WhileStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (condition, body)")
  self.cond:pretty_print(indent .. indent_delta)
  self.body:pretty_print(indent .. indent_delta)
end

function DoStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind)
  self.body:pretty_print(indent .. indent_delta)
end

function RepeatStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (body, condition)")
  self.body:pretty_print(indent .. indent_delta)
  self.cond:pretty_print(indent .. indent_delta)
end

function DeclStatement:pretty_print (indent)
  indent = indent or ''
  local typexpstr = ''
  if self.typeexpression then typexpstr = "typeexpression," end
  print(indent .. self.kind.. ":(name,"..typexpstr.."initializer)")
  print(indent .. indent_delta .. self.name)
  if self.typeexpression then
      print(indent .. indent_delta ..self.typeexpression)
  end
  if self.initializer then
      self.initializer:pretty_print(indent .. indent_delta)
  end
end

function ExprStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind)
  self.exp:pretty_print(indent .. indent_delta)
end

function Assignment:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ': (lvalue, exp)')
  self.lvalue:pretty_print(indent .. indent_delta)
  self.exp:pretty_print(indent .. indent_delta)
end

function GlobalReduce:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": <reduction \'" .. self.reduceop .. '\'>')
  self.global:pretty_print(indent .. indent_delta)
  self.exp:pretty_print(indent .. indent_delta)
end

function FieldWrite:pretty_print (indent)
  indent = indent or ''
  if self.reduceop then
    print(indent .. self.kind .. ": <reduction \'" .. self.reduceop .. '\'>')
  else
    print(indent .. self.kind .. ": <write>")
  end
  self.fieldaccess:pretty_print(indent .. indent_delta)
  self.exp:pretty_print(indent .. indent_delta)
end

function Break:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind)
end

function NumericFor:pretty_print (indent) 
  indent = indent or ''
  if self.step then
    print(indent .. self.kind .. ": (name, lower, upper, step, body)")
  else
    print(indent .. self.kind .. ": (name, lower, upper, body)")
  end
  self.name:pretty_print(indent .. indent_delta)
  self.lower:pretty_print(indent .. indent_delta)
  self.upper:pretty_print(indent .. indent_delta)
  if self.step then self.step:pretty_print(indent .. indent_delta) end
  self.body:pretty_print(indent .. indent_delta)
end

function GenericFor:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (name, set, body)")
  print(indent .. indent_delta .. self.name)
  self.set:pretty_print(indent  .. indent_delta)
  self.body:pretty_print(indent .. indent_delta)
end

function VectorLiteral:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ":")
  for i = 1, #self.elems do
    self.elems[i]:pretty_print(indent .. indent_delta)
  end
end

-- declare other exports
for k,v in pairs({
  AST             = AST,
  LisztKernel     = LisztKernel,
  UserFunction    = UserFunction,
  Block           = Block,
  Expression      = Expression,
  BinaryOp        = BinaryOp,
  UnaryOp         = UnaryOp,
  Reduce          = Reduce,
  TableLookup     = TableLookup,
  VectorIndex     = VectorIndex,
  Global          = Global,
  FieldAccess     = FieldAccess,
  Cast            = Cast,
  QuoteExpr       = QuoteExpr,
  Call            = Call,
  Name            = Name,
  Number          = Number,
  String          = String,
  Bool            = Bool,
  VectorLiteral   = VectorLiteral,
  Statement       = Statement,
  IfStatement     = IfStatement,
  WhileStatement  = WhileStatement,
  DoStatement     = DoStatement,
  RepeatStatement = RepeatStatement,
  ExprStatement   = ExprStatement,
  Assignment      = Assignment,
  FieldWrite      = FieldWrite,
  GlobalReduce    = GlobalReduce,
  DeclStatement   = DeclStatement,
  NumericFor      = NumericFor,
  GenericFor      = GenericFor,
  Break           = Break,
  CondBlock       = CondBlock,
  LuaObject       = LuaObject,
  Where           = Where
}) do A[k] = v end

